[{"name":"Selection Sort","order":1,"height":"300","type":"codepen","url":"249a29e7-6b8e-4c7c-83ab-a23bce597c91","codePenId":"yEpRVr","authorUser":"iMultiThinker","moreMarkdown":"O algoritmo pode ser descrito pelo código a seguir.\nPara garantir que o i-ésimo elemento seja o i-ésimo menor elemento da lista, esse algoritmo primeiro percorre a lista com um loop for.\nEntão, para cada elemento, ele usa outro loop for para encontrar o menor elemento na parte restante da lista.\n\n```javascript\nselectionSort(input) {\n  for(var i=0; i < input.length; i++) {\n    var smallestElement = input[i];\n    for(var j=0; j < input.length; j++) {\n      if(smallestElement > input[j]) {\n        smallestElement = input[j]\n      }\n    }\n    swap(input[i], smallestElement)\n  }\n}\n```\n\nNeste cenário, consideramos a variável *input* como a entrada, portanto, o tamanho da entrada *n* é o número de elementos dentro de List. Suponha que a instrução if e a atribuição de valor limitada pela instrução if levem um tempo constante. Então podemos encontrar a notação Big-O para a função selectionSort analisando quantas vezes as instruções são executadas.\n\nPrimeiro, o loop for interno executa as instruções dentro de n vezes. E então depois que i é incrementado, o laço for interno é executado por n-1 vezes... ...até que ele seja executado uma vez, então ambos os laços for atingem suas condições de término.\n\nNa verdade, isso acaba nos dando uma soma geométrica, e com um pouco de matemática do ensino médio descobriríamos que o loop interno se repetirá por 1+2 … + n vezes, o que equivale a n(n-1)/2 vezes. Se multiplicarmos isso, acabaremos obtendo n²/2-n/2.\n\nQuando calculamos o Big-O, nos importamos apenas com os termos dominantes e **não nos importamos com os coeficientes**. Assim, tomamos o n² como nosso Big-O final. Nós o escrevemos como O(n²), que novamente é pronunciado “Big O squared”.\n\nAgora você pode estar se perguntando, o que é esse “termo dominante”? E por que não nos importamos com os coeficientes? Não se preocupe, vamos analisá-los um por um. Pode ser um pouco difícil de entender no início, mas tudo fará muito mais sentido à medida que você ler a próxima seção.","modified":1664650187339,"authorUrl":"fsdfghfhjk,.kjhgfdssfghjklhgfdsfghjjhgfds","markdown":"Neste módulo, você vai aprender o que é Big-O e entender a importância de dominar este assunto para se dar bem nas entrevistas técnicas.\n\n**O Big-O é a ferramenta mais fundamental para análise do custo de algoritmos.**\n\nÉ importantíssimo que engenheiros de software entendam o Big-O o melhor possível.\n\n<hr />\n\nEm palavras simples, a notação Big-O **descreve a complexidade do seu código usando termos algébricos.**\n\nPara entender o que é Big-O, podemos dar uma olhada em um exemplo típico, `O(n²)`, que geralmente é pronunciado “Big-O quadrado”.\nA letra *n* aqui representa o tamanho da entrada, e a função `g(n) = n²` dentro do `O()` nos dá uma ideia de quão complexo é o algoritmo em relação ao tamanho da entrada.\n\nUm algoritmo típico que tem a complexidade de `O(n²)` seria o algoritmo de ordenação por seleção.\nA classificação por seleção é um algoritmo de classificação que itera pela lista para garantir que cada elemento no índice seja o i-ésimo menor/maior elemento da lista. O exemplo abaixo dá um visual disso.","created":1664646096933,"authorName":"Talha Habib","title":"O que é Big-O"},{"created":1664669267645,"title":"Teste seus conhecimentos","questions":[{"items":["Quanto tempo meu algoritmo demora para rodar, em relação à entrada de dados?","Quanto tempo meu algoritmo demora para rodar, independentemente da entrada de dados?","Quanto tempo meu algoritmo demora para rodar, se outros programas estiverem rodando ao mesmo tempo?","Quanto tempo meu algoritmo demora para rodar, se o computador estiver livre?",""],"explanation":"Assista o vídeo do Sugi.","question":"O Big-O ajuda a responder qual pergunta?"},{"question":"Complexidade de tempo pode ser definido como:","explanation":"Assista o vídeo do Sugi.","items":["Uma forma de demonstrar como o tempo de execução de um algoritmo aumenta conforme o tamanho da entrada de dados aumenta.","Uma forma de tentar fazer o tempo de execução de um algoritmo ser o mesmo mesmo se o tamanho da entrada de dados aumentar.","","",""]},{"question":"Existem casos onde o tempo de execução não varia em nada mesmo se a entrada de dados aumentar bastante?","items":["Sim","Verdade","Mentira","",""],"explanation":"Big-O constante"}],"url":"37aab6d5-5ad8-42d4-aec0-39c6c2fce44f","order":4,"type":"quiz","markdown":null,"modified":1664927783292},{"title":"Big-O e Time Complexity","modified":1664669121371,"type":"youtube","created":1664669121371,"order":2,"moreMarkdown":null,"url":"ca2d7d8c-58e0-4093-95ae-4f7c9ef9b8af","markdown":"Assista o vídeo abaixo, preferencialmente sem legenda, para fixar e entender mais detalhadamente como o Big-O se relaciona com o tempo que leva para rodar um algoritmo. \n\nO vídeo foi produzido por Sugi, então aproveita para se habituar com o sotaque oriental =D.","videoId":"D6xkbGLQesk"},{"modified":1664927771670,"title":"Consumidor mais rico - Leetcode 1672","created":1664670099639,"markdown":"Para resolver o exercício do [Leetcode 1672](https://leetcode.com/problems/richest-customer-wealth/), uma solução simples seria ter um loop dentro do outro.\n```javascript\nforeach(customer){\n  foreach(value){\n    sum += value;\n  }\n}\n```\n* Você consegue dizer qual é a complexidade de tempo desta solução?\n* Você consegue desenvolver uma solução com complexidade menor (mais rápido)?","order":3,"type":"text","url":"de318a5f-dee5-47db-8928-172bb13787d9"}]