[{"order":3,"title":"Teste seus conhecimentos","url":"038e6594-5eab-47f6-8049-f52d0525324f","created":1663353228411,"type":"text","markdown":"Aqui vão alguns exercícios para praticar operações em array.\n\n- [LeetCode 1480 - Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\n- [LeetCode 1929 - Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\n\n\n*Dica: Leia os problemas com atenção para entender o que deve ser feito e pense nas possíveis soluções antes de escrever o código.*","modified":1663353228411},{"order":1,"type":"text","url":"2c70dca7-b667-4fd0-9e0b-c4f9a4e4cc27","markdown":"**Nesta lição você entenderá o funcionamento das operações básicas de um array como criação, inserção, busca, atualização e deleção. Além de aprender a complexidade de cada uma delas.**\n\n## 1. Criar um Array\n\n\nPara criar um array são necessários os seguintes passos:\n- Declarar - O sistema cria uma variável de referência para o array\n- Instanciar - O sistema aloca o espaço de memória\n\n~~~Java\n// declara\nint[] arr; \n\n// instancia\narr = new int[3]; \n\n// declara e instancia \nint[] arr2 = new int[3];\n~~~\nNesse trecho de código vemos como é possível declarar e instanciar um array na memória!\n\n> Complexidade de Tempo: O(1)<br>\n> Complexidade de Espaço: O(n)\n\n\n## 2. Inserir valores em um Array\nDado um array de tamanho *n* e sabendo que o tamanho de um array não pode ser alterado, adicionar um elemento em um array pode acontecer de duas maneiras:\n\n1. Criando um novo array:\n\n- Criar um novo array de tamanho n+1\n- Copia os valores do array original para o novo array \n- Insere o elemento na posição n+1\n\n> Nesse caso, está sendo criada uma cópia de todos os valores já existentes no array para um novo endereço de memória.\n\n2. Realizando a operação de *shift*\n- Identifica a posição que deseja inserir\n- Todos os elementos a partir da posição que se deseja inserir devem ter o índice incrementado (operação de *shift*)\n- A posição desejada fica \"livre\" e pode ser preenchida com o novo valor \n\n> Nesse caso, o valor que está na última posição do array irá se perder! \n\nPara ambos a complexidade de tempo e espaço são as mesmas:\n\n> Complexidade de Tempo: O(n)<br>\n> Complexidade de Espaço: O(n)\n\n## 3. Atualizar valores em um Array\nA atualização de um elemento do array acontece da mesma forma que a inserção. Na verdade, a inserção é uma atualização! Pense um pouco, ao declarar e instanciar um array, um espaço de memória será dedicado à essa nova estrutura! Essa nova estrutura poderá ser preenchida com valores default ou aletatórios (dependendo da linguagem) e podem até permanecer como nulos. Porém, quando executamos a instrução abaixo:\n~~~Java\narr[2] = 5;\n~~~\nEstamos atualizando o valor que contém na posição 2 (qualquer ele que seja) pelo novo valor informado, no caso 5.\n\n> Complexidade de Tempo: O(1)<br>\n> Complexidade de Espaço: O(1)\n\n## 4. Deletar valores de um Array\n\nDado um array de tamanho *n* e sabendo que o tamanho de um array não pode ser alterado, para deletar um elemento em um array pode-se seguir os seguintes passos:\n\n- Identificar a posição que deseja ser deletada\n- Fazer a operação de *shift* de todas as posições da frente até a posição a ser deletada fique no final do array\n- Setar um valor default para a posição que acabou de chegar no final do array\n\n> Complexidade de Tempo: O(n)<br>\n> Complexidade de Espaço: O(n)\n\n## 5. Consultar valores de um Array\nExistem duas formas de consultar ou buscar valores em um array.\n- Consulta pelo índice:\n\n> Nesse formato é conhecido o índice do elemento e, por meio desse índice, é possível recuperar o valor dessa posição.\n> ~~~Java\n> int res = arr[2];\n> ~~~\n> Nesse trecho de código está sendo atribuído à variável *res* o valor que contém na posição 2 da array *arr*\n\n>> Complexidade de Tempo: Por se tratar de um acesso direto à posição do elemento a complexidade dessa operação é O(1)<br>\n>> Complexidade de Espaço: O(1)\n\n- Percorrer o array:\n\n> Nesse caso, não é conhecido o endereço exato de um elemento e é necessário buscar por todo array até encontrar o valor desejado\n> ~~~Java\n> for(int i = 0; i < arr.length; i++){\n>     if(arr[i] == 5) int res = arr[i];\n> }\n> ~~~\n> Perceba que nesse trecho de código é necessário percorrer o array e verificar o valor que contém em cada posição. Nesse caso, sabemos que o valor 5 está na posição 2 do array, portanto, \n> não foi necessário visitar a última posição do array para encontrar o valor desejado. Mas imagine que o valor 5 estivesse na última posição do array, assim precisariamos percorrer todo o \n> array para encontrar o valor que está sendo buscado! \n\n>> Complexidade de Tempo: Uma vez que não se sabe a posição exata do valor desejado, é necessário percorrer o array, portanto, a complexidade é O(n) pois o valor pode estar na última posição do array.<br>\n>> Complexidade de Espaço: O(1)","modified":1663422962009,"created":1663242198818,"title":"Operações Básicas"},{"order":2,"url":"f6bf4b20-c9a0-44ff-b6ec-d44891e59110","created":1663423061866,"markdown":"O vídeo abaixo explica em detalhes o funcionamento de algumas operações em array.","title":"Entendo melhor sobre as operações","type":"youtube","videoId":"B2KusJcbVIg","moreMarkdown":null,"modified":1663428353923}]