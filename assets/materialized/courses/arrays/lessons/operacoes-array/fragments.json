[{"type":"text","order":3,"title":"Mão na massa","url":"038e6594-5eab-47f6-8049-f52d0525324f","created":1663353228411,"markdown":"Aqui vão alguns exercícios para praticar operações em array.\n\n- [LeetCode 1480 - Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\n- [LeetCode 1929 - Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\n\n\n*Dica: Leia os problemas com atenção para entender o que deve ser feito e pense nas possíveis soluções antes de escrever o código.*","modified":1663503821513},{"url":"130b5a6a-197f-4b94-a296-0ae2644f4944","modified":1663531060238,"type":"quiz","created":1663505154528,"title":"Teste seus conhecimentos","questions":[{"question":"De acordo com o vídeo na seção \"Entendendo melhor sobre as operações\", o que é possível afirmar sobre a inserção de novos elementos em um array?","explanation":"Assista ao vídeo com atenção!","items":["Inserir um elemento em um array é uma operação custosa computacionalmente falando, principalmente se a inserção for no início do array","Independente da posição que o novo elemento deve ser inserido, a melhor opção é sempre fazer a cópia do array original","Utilizar o método que elimina o último elemento do array é uma boa opção pois o último elemento não é tão importante para resolução de um problema","Inserir elementos em um array é uma operação simples e, portanto, deve-se sempre utilizar em uma entrevista técnica",""]},{"question":"Durante uma entrevista técnica, o entrevistador te falou o problema e você optou por usar array como uma estrutura para te auxiliar a resolver o problema. Após comunicar sobre essa sua escolha, o entrevistador pergunta por qual motivo você escolheu essa estrutura de dados e não alguma outra. Qual a resposta mais adequada?","items":["O problema tem um escopo limitado de itens e serão armazenados apenas para consultas diretas","A entrada de dados variar bastante e será conhecido o índice de cada item novo na estrutura","Array é a estrutura mais conhecida entre os programadores e, por isso, se aplica a esse cenário","Todos os elementos serão armazenados sequencialmente na memória, isso torna mais fácil a remoção do primeiro elemento",""],"explanation":"Leia a página 30 do livro Grokking Agorithms"}],"order":4,"markdown":null},{"modified":1663530057576,"type":"text","markdown":"**Nesta lição você entenderá o funcionamento das operações básicas de um array como criação, inserção, busca, atualização e deleção. Além de aprender a complexidade de cada uma delas.**\n\n## 1. Criar um Array\n\n\nPara criar um array são necessários os seguintes passos:\n- Declarar - O sistema cria uma variável de referência para o array\n- Instanciar - O sistema aloca o espaço de memória\n\n~~~Java\n// declara\nint[] arr; \n\n// instancia\narr = new int[3]; \n\n// declara e instancia \nint[] arr2 = new int[3];\n~~~\nNesse trecho de código vemos como é possível declarar e instanciar um array na memória!\n\n> Complexidade de Tempo: O(1)<br>\n> Complexidade de Espaço: O(n)\n\n\n## 2. Inserir valores em um Array\nDado um array de tamanho *n* e sabendo que o tamanho de um array não pode ser alterado, adicionar um elemento em um array pode acontecer de duas maneiras:\n\n1. Criando um novo array:\n\n- Criar um novo array de tamanho n+1\n- Copia os valores do array original para o novo array \n- Insere o elemento na posição n+1\n\n> Nas páginas 24 e 25 do livro Grokking Algorithms é detalhado esse formato com o exemplo de um grupo de amigos no cinema, um exemplo prático e que ajuda na compreensão do funcionamento da memória para esse cenário.\n\n\n2. Realizando a operação de *shift*\n- Identifica a posição que deseja inserir\n- Todos os elementos a partir da posição que se deseja inserir devem ter o índice incrementado (operação de *shift*)\n- A posição desejada fica \"livre\" e pode ser preenchida com o novo valor \n\n> Nesse caso, o valor que está na última posição do array irá se perder! \n\nPara ambos a complexidade de tempo e espaço são as mesmas:\n\n> Complexidade de Tempo: O(n)<br>\n> Complexidade de Espaço: O(n)\n\n## 3. Atualizar valores em um Array\nA atualização de um elemento do array acontece da mesma forma que a inserção. Na verdade, a inserção é uma atualização! Pense um pouco, ao declarar e instanciar um array, um espaço de memória será dedicado à essa nova estrutura! Essa nova estrutura poderá ser preenchida com valores default ou aletatórios (dependendo da linguagem) e podem até permanecer como nulos. Porém, quando executamos a instrução abaixo:\n~~~Java\narr[2] = 5;\n~~~\nEstamos atualizando o valor que contém na posição 2 (qualquer ele que seja) pelo novo valor informado, no caso 5.\n\n> Complexidade de Tempo: O(1)<br>\n> Complexidade de Espaço: O(1)\n\n## 4. Deletar valores de um Array\n\nDado um array de tamanho *n* e sabendo que o tamanho de um array não pode ser alterado, para deletar um elemento em um array pode-se seguir os seguintes passos:\n\n- Identificar a posição que deseja ser deletada\n- Fazer a operação de *shift* de todas as posições da frente até a posição a ser deletada fique no final do array\n- Setar um valor default para a posição que acabou de chegar no final do array\n\n\n> Complexidade de Tempo: O(n)<br>\n> Complexidade de Espaço: O(n)\n\n## 5. Consultar valores de um Array\nExistem duas formas de consultar ou buscar valores em um array.\n- Consulta pelo índice:\n\n> Como é dito na página 30 do livro Grokking Algorithms esse é o *acesso randomico* á uma posição. Ou seja, é possível chegar diretamente no elemento desejado e **esse é o grande diferencial dos arrays**.\n\n\n> Nesse formato é conhecido o índice do elemento e, por meio desse índice, é possível recuperar o valor dessa posição.\n> ~~~Java\n> int res = arr[2];\n> ~~~\n> Nesse trecho de código está sendo atribuído à variável *res* o valor que contém na posição 2 da array *arr*\n\n\n> Complexidade de Tempo: O(1)<br>\n> Complexidade de Espaço: O(1)\n\n- Percorrer o array:\n\n> Como é dito na página 30 do livro Grokking Algorithms esse é o *acesso sequencial* á uma posição. Ou seja, é possível para chegar à uma posição é necessário percorrer por todas as anteriores.\n\n\n> Nesse caso, não é conhecido o endereço exato de um elemento e é necessário buscar por todo array até encontrar o valor desejado\n> ~~~Java\n> for(int i = 0; i < arr.length; i++){\n>     if(arr[i] == 5) int res = arr[i];\n> }\n> ~~~\n> Perceba que nesse trecho de código é necessário percorrer o array e verificar o valor que contém em cada posição. Nesse caso, sabemos que o valor 5 está na posição 2 do array, portanto, \n> não foi necessário visitar a última posição do array para encontrar o valor desejado. Mas imagine que o valor 5 estivesse na última posição do array, assim precisariamos percorrer todo o \n> array para encontrar o valor que está sendo buscado! \n\n> Complexidade de Tempo: O(n)<br>\n> Complexidade de Espaço: O(1)","order":1,"url":"2c70dca7-b667-4fd0-9e0b-c4f9a4e4cc27","title":"Operações Básicas","created":1663242198818},{"type":"youtube","markdown":"O vídeo abaixo explica em detalhes o funcionamento de algumas operações em array.","videoId":"B2KusJcbVIg","url":"f6bf4b20-c9a0-44ff-b6ec-d44891e59110","modified":1663428353923,"created":1663423061866,"moreMarkdown":null,"order":2,"title":"Entendo melhor sobre as operações"}]